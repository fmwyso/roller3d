<!DOCTYPE html>
<html lang="en">
	<style>
		* {

		box-sizing: border-box;
		overflow: hidden;
		}
		html {
		box-sizing: border-box;

		}
		*, *:before, *:after {
		box-sizing: inherit;
		}
		body { margin: 0; }
		.frame { 
		display: flex;
		height: 100vh;
		max-width:100%;
		border: 0px solid cyan;
    	box-sizing: border-box;
		}
		#editor {
		font-family: monospace;
		padding: .5em;
		background: #444;
		color: white;
		max-width:500px;
		}
		canvas { 
		min-width: 100%;
		height: 100%;
		}
		.rollDiv {
			text-align: center;
		}
		.choicesDiv {
			text-align: center;
		}
		input {
			text-align: right;
		}
		input[type=number] {
    		height: 30px;
		}
		input[type=number]::-webkit-inner-spin-button {  
			width: 14px;
			height: 30px;
		}
		input[type=number]:hover::-webkit-inner-spin-button {  
			width: 14px;
			height: 30px;
		}
		.rollResultsDiv {
			text-align: center;
		}
		.rollQueueDiv {
			text-align: center;
		}
		.twitchIntegrationDiv {
			text-align: center;
		}
		.googleIntegrationDiv {
			text-align: center;
		}
		.connectWithGoogle {
			cursor: pointer;
		}
		.rollQueueStartStop {
			text-align: center;
		}
		.sheetLogDiv {
			text-align: center;
		}
		.bitsPerRollDiv{
			text-align: center;
		}
		a:link {
			color: white;
			background-color: transparent;
			text-decoration: underline;
			font-style: italic;
		}

		a:visited {
			color: white;
			background-color: transparent;
			text-decoration: underline;
			font-style: italic;
		}

		a:hover {
			color: lightblue;
			background-color: transparent;
			text-decoration: underline;
		}

		a:active {
			color: white;
			background-color: transparent;
			text-decoration: underline;
		}
	</style>

	<head>
		<title>Roller3D by fmwyso</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="https://accounts.google.com/gsi/client" onload="gisInit()" async defer></script>
		<script src="https://apis.google.com/js/api.js" onload="gapiLoad()" async defer></script>
	</head>

	<body>

		<div class="frame">
			<div id="result">
			  <canvas></canvas>
			</div>
			<div id="editor">
				<div class="rollDiv">
					<label for="nameBox">Name</label>
					<input type="text" name="nameBox" id="nameBox" value="Bear"></input>
					<label for="rolls">Roll Count</label>
					<input type="number" min="1" name="roll_count" id="roll_count" value=1></input>
					<button type="button" id="roll_btn">Add to Roll Queue</button>
				</div>

				<div class="choicesDiv">
					<label for="choices">Possible Choices</label>
					<br />
					<textarea id="choices" name="choices" rows="12" cols="50">Turkey&#13;&#10;Ham&#13;&#10;Eggs&#13;&#10;Gravy&#13;&#10;Apples&#13;&#10;Macaroni&#13;&#10;Eggnog</textarea>
					<br />
					<button type="button" id="updateChoicesButton">Update Choices</button>
				</div>

				<div class="rollQueueDiv"> 
					<label for="rollQueueDisplay">Roll Queue</label>
					<br />
					<textarea id="rollQueueDisplay" name="rollQueueDisplay" rows="12" cols="50" readonly></textarea>
				</div>

				<div class="rollQueueStartStop">
					<button type="button" id="btnToggleQueue">START roll queue</button>
				</div>

				<div class="twitchIntegrationDiv" id="twitchIntegrationDiv">
					<a id="connectWithTwitch"><img src="./connect_with_twitch.png"></img><br />Connect Twitch account for new subs to be automatically queued! WARNING: !! DO NOT SHOW ANYONE YOUR BROWSER'S URL WHEN CONNECTING WITH TWITCH !! It contains an access token enabling people to find info about your account. If you accidentally leak it, go to https://www.twitch.tv/settings/connections and disconnect "Roller3D". </a>
				</div>

				<div class="rollResultsDiv">
					<label for="rollResults">Roll Results</label>
					<br />
					<textarea id="rollResults" name="rollResults" rows="12" cols="50" readonly></textarea>
				</div>

				<div class="sheetLogDiv">
					<label for="sheetLogText">Enter sheetdb API URL</label>
					<input type="password" name="sheetdb_api_url" id="sheetdb_api_url"></input>
					<br />
					<p>Enter a valid sheetdb API url (with fields "time_stamp", "name", "roll_count", "rewards"). Once a users' rolls are completed, a new row will be added with the roll results.</p>
				</div>

				<div class="googleIntegrationDiv">
					<a class="connectWithGoogle" id="connectWithGoogle" onclick="get_token()"><img src="./connect_with_google.png" ></img></a>
					<p class="googleInfo" id="googleInfo">Connect with Google to create a new spreadshot logging all subs and diagnostic information.</p>
				</div>

				<div class="bitsPerRollDiv">
					<label for="bitsPerRoll">Enter amount of bits per roll</label>
					<input type="number" name="bitsPerRoll" id="bitsPerRoll" min=1 value=250></input>
				</div>

				<div class="rollDiv" style="text-align: center">
					<a href="https://github.com/fmwyso/roller3d">Click here for steps on how to use this page</a>
					<p>
						Written by fmwyso; feel free to send any comments, questions or suggestions to me on Discord (fmwyso#3492). For the time being, only Chrome is supported. FireFox seems to be buggy for some reason... 

						<br />
						This page was made possible by the following libraries: <a href="https://developers.google.com/sheets/api/guides/concepts">Google Sheets API</a>, <a href="https://docs.sheetdb.io/">sheetdb</a>, <a href="https://threejs.org/">threejs</a> and <a href="https://createjs.com/tweenjs">tweenjs</a>. 
						I want to thank the following authors/pages for their examples & code snippets that made this development possible.

						<br />
						<a href="https://threejs.org/examples/?q=bloom#webgl_postprocessing_unreal_bloom_selective">Temdog007's threejs example</a>
						<br />
						<a href="https://threejs.org/examples/webgl_shadowmap.html">threejs webgl_shadowmap example</a>
						<br />
						<a href="http://stemkoski.github.io/Three.js/index.html">stemkoski's threejs examples</a>
						<br />
						<a href="https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container">gman's stackoverflow reply on resizing canvas</a>
						<br />
						<a href="https://discourse.threejs.org/t/load-font-into-global-variable-efficiency/31608/2">hofk's reply on font loading for threejs</a>
						<br />
						<a href="https://github.com/twitchdev/pubsub-javascript-sample/blob/main/main.js">Twitch's PubSub Javascript Sample</a>
						<br />
						<a href="https://barrycarlyon.github.io/twitch_misc/authentication/implicit_auth/">Barry Carlyon's implicit twitch example</a>
						<br />
						<a href="https://github.com/sheetdb/sheetdb-js">Sheetdb's javascript library (used as an example)</a>
						<br />
						<a href="https://dev.to/jessesbyers/create-a-google-sheet-and-write-data-using-the-google-sheets-api-1mac">Jesse Smith Byers' Google Sheets API example</a>
						<br />
						<a href="https://stackoverflow.com/a/70772647">Iamblichus' reply describing how to use GIS</a>
						<br />
						<a href="https://scriptverse.academy/tutorials/html5-window-postmessage.html">Dennis Gabil's examples of window.postMessage()</a>
					</p>
				</div>
			</div>
		  </div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.138.0/build/three.module.js"
				}
			}
		</script>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>

		<!-- Google Sheets & GIS Integration -->
		<script>
			var tokenClient;
			var g_access_token = null;
			var sheet_map = new Map();
			var spreadsheetId = null;

			function gapiStart() {
					gapi.client.init({
				}).then(function() {
					gapi.client.load('sheets', 'v4');
				}).then(function(response) {
					gisInit();
					console.log('discovery document loaded');
				}, function(reason) {
					console.log('Error: ' + reason.result.error.message);
				});
			}

			function gapiLoad() {
				gapi.load('client', gapiStart)
			}

			function gisInit() {
				tokenClient = google.accounts.oauth2.initTokenClient({
					client_id: '441029014764-tl4fr1os2p7hkdn5267jvp4k6f1v2cri.apps.googleusercontent.com',
					scope: 'https://www.googleapis.com/auth/spreadsheets',
					callback: (tokenResponse) => {
					g_access_token = tokenResponse.access_token;
					createSpreadsheet();
					},
				});
			}

			function get_token() {
				tokenClient.requestAccessToken();
			}

			function getTimeStampString() {
				let curDateTime = new Date();

				let year  = curDateTime.getFullYear().toString().padStart(4, '0');
				let day   = curDateTime.getDate().toString().padStart(2, '0');
				let month = (curDateTime.getMonth() + 1).toString().padStart(2, '0');

				let hour   = curDateTime.getHours();
				let am_pm  = "AM";

				if(hour >= 12){
					am_pm = "PM";

					if(hour > 12) {
						hour -= 12;
					}
				}

				hour = hour.toString().padStart(2, '0');

				let minute = curDateTime.getMinutes().toString().padStart(2, '0');
				let second = curDateTime.getSeconds().toString().padStart(2, '0');

				return day + "/" + month + "/" + year + " " + hour + ":" + minute + ":" + second + " " + am_pm;
			}

			async function createSpreadsheet() { 
				let title = "Roller3D Log (" + getTimeStampString() + ")"
				var request = {
					properties: {
						title: title
					},
					sheets: [
						{
							properties: {
								title: "Rolls",
								gridProperties: {
								columnCount: 4,
								rowCount: 2, 
								frozenRowCount: 1
								},
								tabColor: { 
								red: 0.0,
								green: 1.0,
								blue: 0.0
								},
							},
						},
						{
							properties: {
								title: "Debug",
								gridProperties: {
								columnCount: 2,
								rowCount: 2, 
								frozenRowCount: 1
								},
								tabColor: { 
								red: 0.0,
								green: 0.0,
								blue: 1.0
								},
							},
						},           
					],
				};

				var response = await window.gapi.client.sheets.spreadsheets.create(request);

				console.log(response);

				spreadsheetId = response.result.spreadsheetId;

				for (let sheet_idx = 0; sheet_idx < response.result.sheets.length; sheet_idx++) {
					sheet_map.set(response.result.sheets[sheet_idx].properties.title, response.result.sheets[sheet_idx].properties.sheetId);
				}

				writeHeaders(spreadsheetId, sheet_map.get("Rolls"), ["Rolled Timestamp", "Received Timestamp", "Name", "Reward"])
				writeHeaders(spreadsheetId, sheet_map.get("Debug"), ["Timestamp", "Info"])

				document.querySelector(".googleIntegrationDiv").innerHTML = "<a href='" + response.result.spreadsheetUrl + "' target='_blank'>Now logging to spreadsheet: '" + title + "'. Click here to open spreadsheet.</a>";
			}

			async function writeHeaders(spreadsheetId, sheetId, values) { 
				let values_array = []

				for(let value_idx = 0; value_idx < values.length; ++value_idx) {
					values_array.push({userEnteredValue: {stringValue: values[value_idx]}})
				}

				var request = window.gapi.client.sheets.spreadsheets.batchUpdate({
					spreadsheetId: spreadsheetId,
					"resource": {
						"requests": [
							{
								"updateCells": {

									"rows": 
										{
											values: values_array
										}
									,
									"fields": "*",
									"range": {
										"sheetId": sheetId,
										"startRowIndex": 0,
										"endRowIndex": 1,
										"startColumnIndex": 0,
										"endColumnIndex": values.length
									}
								},
							},
							{
								"autoResizeDimensions": {
									"dimensions": {
									"sheetId": sheetId,
									"dimension": "COLUMNS",
									"startIndex": 0,
									"endIndex": values.length
									}
								}
							}
						]
					}
				});
					
				request.then(function(response) {
					// TODO: Change code below to process the `response` object:
					console.log(response.result);
				}, function(reason) {
					console.error('error: ' + reason.result.error.message);
				});
			}
		</script>

		
		<script type="module">
			var access_token = null;

			var base_url = location.protocol + '//' + location.host + location.pathname;

			document.querySelector("#connectWithTwitch").href = "https://id.twitch.tv/oauth2/authorize?response_type=token&client_id=zzkq9lw1rprzcr2edg6hn61ducjvri&redirect_uri=" + base_url + "&scope=channel:read:subscriptions+bits:read";

			// From https://github.com/sheetdb/sheetdb-js/blob/master/src/write.js
			function write(url, data, options) {
			return new Promise(function (resolve, reject) {
				var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
				xhr.open("POST", url, true);
				xhr.onload = function () {
				if (this.status >= 200 && this.status < 300) {
					resolve(JSON.parse(xhr.responseText));
				} else {
					reject({
					status: this.status,
					statusText: xhr.statusText
					});
				}
				};

				xhr.setRequestHeader('Content-Type', 'application/json; charset=UTF-8');
				xhr.onerror = function (e) {
				reject(e);
				};

				xhr.send(JSON.stringify(data));
			});
			}

			var ws;
			var readyToSend = false;

			// Source: https://www.thepolyglotdeveloper.com/2015/03/create-a-random-nonce-string-using-javascript/
			function nonce(length) {
				var text = "";
				var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
				for (var i = 0; i < length; i++) {
					text += possible.charAt(Math.floor(Math.random() * possible.length));
				}
				return text;
			}

			function heartbeat() {
				var message = {
					type: 'PING'
				};
				logToConsoleAndDebug(('SENT: ' + JSON.stringify(message) + '\n'));
				ws.send(JSON.stringify(message));
			}

			function listen(topic, auth_token) {
				var message = {
					type: 'LISTEN',
					nonce: nonce(15),
					data: {
						topics: [topic],
						auth_token: auth_token
					}
				};
				logToConsoleAndDebug('SENT: ' + JSON.stringify(message) + '\n');
				ws.send(JSON.stringify(message));
			}

			function connect(channel_id, auth_token) {
				var heartbeatInterval = 1000 * 60; //ms between PING's
				var reconnectInterval = 1000 * 3; //ms to wait before reconnect
				var heartbeatHandle;

				ws = new WebSocket('wss://pubsub-edge.twitch.tv');

				ws.onopen = function(event) {
					readyToSend = true;
					logToConsoleAndDebug('INFO: Socket Opened\n');
					heartbeat();
					heartbeatHandle = setInterval(heartbeat, heartbeatInterval);
					listen("channel-subscribe-events-v1." + channel_id, auth_token);
					// listen("channel-points-channel-v1." + channel_id, auth_token);
					listen("channel-bits-events-v2." + channel_id, auth_token);
				};

				ws.onerror = function(error) {
					logToConsoleAndDebug('ERR:  ' + JSON.stringify(error) + '\n');
				};

				ws.onmessage = function(event) {
					var top_level_message = JSON.parse(event.data);

					logToConsoleAndDebug('RECV: ' + JSON.stringify(top_level_message) + '\n');
					if (top_level_message.type == 'RECONNECT') {
						logToConsoleAndDebug('INFO: Reconnecting...\n');
						setTimeout(connect, reconnectInterval);
					}
					if (top_level_message.type == "MESSAGE") {
						var topic = top_level_message.data.topic;

						var twitch_message = JSON.parse(top_level_message.data.message);

						if (topic.startsWith("channel-points-channel-v1")) {
							var name = twitch_message.data.redemption.user.display_name;
							var count = twitch_message.data.redemption.reward.cost;

							queueRoll(name, count);
						}
						else if(topic.startsWith("channel-bits-events-v2")) {
							if(twitch_message.data.is_anonymous == false) {
								var user_id = twitch_message.data.user_id;
								var bits_per_roll = parseInt(document.querySelector("#bitsPerRoll").value);
								var count = Math.floor(twitch_message.data.bits_used / bits_per_roll);

								if(count > 0) {
									fetch(
										'https://api.twitch.tv/helix/users?id=' + user_id,
										{
											"headers": {
												"Client-ID": "zzkq9lw1rprzcr2edg6hn61ducjvri",
												"Authorization": "Bearer " + access_token
											}
										}
									)
									.then(resp => resp.json())
									.then(resp => {
										var name = resp["data"][0]["display_name"];
										
										queueRoll(name, count);
									})
									.catch(err => {
										logToConsoleAndDebug(err);
									});
								}
							}
						}
						else if(topic.startsWith("channel-subscribe-events-v1")) {
							var name = null;
							var count = null;

							if(twitch_message.context == "anonsubgift") {
								name = twitch_message.recipient_display_name;
							}
							else {
								name = twitch_message.display_name;
							}
							
							count = twitch_message.multi_month_duration;

							if(count == 0) {
								count = 1;
							}

							queueRoll(name, count);
						} else {
							logToConsoleAndDebug("Found topic that I wasn't listening for?: " + topic);
						}
					}
				}

				ws.onclose = function() {
					logToConsoleAndDebug('INFO: Socket Closed\n');
					clearInterval(heartbeatHandle);
					logToConsoleAndDebug('INFO: Reconnecting...\n');
					setTimeout(connect, reconnectInterval);
				};
			}

			function updateRollQueueDisplay() {
				let rollQueueDisplay = document.querySelector("#rollQueueDisplay");

				let resultsMessages = [];

				if(rollTotalCounts.size >= 1) {
					let first_key = rollTotalCounts.keys().next().value

					for (let [key, value] of rollTotalCounts) {
						if(is_rolling && key == first_key) {
							continue;
						}
						resultsMessages.push(key + " (" + value + ")");
					}
				}

				rollQueueDisplay.value = resultsMessages.join('\n');
			}

			function queueRoll(name, roll_count) {
				if(rollTotalCounts.has(name)) {
					rollTotalCounts.set(name, rollTotalCounts.get(name) + roll_count);
				}
				else {
					rollTotalCounts.set(name, roll_count);
					rollCurSpinCounts.set(name, 0);
					rollTimestamps.set(name, []);
				}

				let timestampString = getTimeStampString();
				for(let roll_i = 0; roll_i < roll_count; ++roll_i) { 
					rollTimestamps.get(name).push(timestampString);
				}

				updateRollQueueDisplay();
				if(name == getCurRollName()) {
					updateRollCount();
				}

				logToConsoleAndDebug("Queue'd " + roll_count + " roll(s) for " + name + " with time stamp: " + timestampString);
			}

			import * as THREE from 'three';

			import Stats from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/libs/stats.module.js';

			import { GLTFLoader } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/loaders/GLTFLoader.js';
			import { FontLoader } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/loaders/FontLoader.js';
			import { TextGeometry } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/geometries/TextGeometry.js';
			import { RoomEnvironment} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/environments/RoomEnvironment.js';
			import { UnrealBloomPass} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/UnrealBloomPass.js';
			import { RenderPass} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/RenderPass.js';
			import { EffectComposer} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/EffectComposer.js';
			import { ShaderPass} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/ShaderPass.js';

			import { TWEEN } from 'https://unpkg.com/three@0.139.0/examples/jsm/libs/tween.module.min.js';

			const light_on_map = new THREE.TextureLoader().load( 'light_on.jpg' );
			light_on_map.wrapS = light_on_map.wrapT = THREE.RepeatWrapping;
			light_on_map.anisotropy = 16;

			const light_off_map = new THREE.TextureLoader().load( 'black.jpg' );
			light_off_map.wrapS = light_off_map.wrapT = THREE.RepeatWrapping;
			light_off_map.anisotropy = 16;

			const light_on_mat = new THREE.MeshPhongMaterial( { map: light_on_map, side: THREE.DoubleSide } );
			const light_off_mat = new THREE.MeshPhongMaterial( { map: light_off_map, side: THREE.DoubleSide } );

			const darkMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );
			const materials = {};

			var rollResultsCount = new Map();
			var rollResultsTextMesh = new Map();
			let rollResultsGroup = new THREE.Group();

			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			const FLOOR = - 250;

			let camera, scene, renderer, bloomComposer, finalComposer;
			let bloomLayer;
			let container, stats;

			let spinnerTween = null;

			let segments = [];
			let choices = [];
			const segmentGroup = new THREE.Group();
			let rewardsFadeOut = [];

			let rollQueue = [];
			let curRoll;

			let nameTextMesh;
			let rollCountMesh;

			let is_queue_active = false;

			let rewardsYPositions = new Map([
				[0, 4],
				[1, 5],
				[2, 3], 
				[3, 6], 
				[4, 2], 
				[5, 7], 
				[6, 1], 
				[7, 8], 
				[8, 9],
			]);

			const NEAR = 10, FAR = 3000;

			const morphs = [];

			let light;

			const clock = new THREE.Clock();

			let is_rolling = false;
			let rollTotalCounts = new Map();
			let rollCurSpinCounts = new Map();
			let rollTimestamps = new Map();

			let lastRollTime;

			// From https://discourse.threejs.org/t/load-font-into-global-variable-efficiency/31608/2
			const fontLoader = new FontLoader();
			let threeFont;
			fontLoader.load( '//cdn.rawgit.com/mrdoob/three.js/master/examples/fonts/gentilis_bold.typeface.json', font => { threeFont = font; init(); animate(); } );

			// https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container
			function resizeCanvasToDisplaySize(skip_composer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				if (canvas.width !== width ||canvas.height !== height) {
					// you must pass false here or three.js sadly fights the browser
					renderer.setSize(width, height, false);

					if(skip_composer === false) {
						bloomComposer.setSize(width, height);
						finalComposer.setSize(width, height);
					}
					camera.updateProjectionMatrix();
  				}
			}

			function init() {

				bloomLayer = new THREE.Layers();
				bloomLayer.set( 1 );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 23, 1920 / 1080, NEAR, FAR );
				camera.position.set(-200, 0, 800 );
				camera.rotateY(-.40);
				// camera.position.set(-300, 80, 200);
				// SCENE
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 /*0x59472b*/ );

				// LIGHTS

				const ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 5, 0.3 );
				light.position.set( 0, 1500, 1000 );
				light.target.position.set( 0, 0, 0 );

				scene.add( light );

				// RENDERER

				renderer = new THREE.WebGLRenderer( { canvas: document.querySelector("canvas"),  antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				resizeCanvasToDisplaySize(true);

				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.autoClear = false;

				// CONTROLS
				createScene();

				// STATS
				const urlParams = new URLSearchParams(window.location.hash.substring(1));
				
				if(urlParams.has("access_token")) {
					access_token = urlParams.get('access_token');

					fetch(
						'https://api.twitch.tv/helix/users',
						{
							"headers": {
								"Client-ID": "zzkq9lw1rprzcr2edg6hn61ducjvri",
								"Authorization": "Bearer " + access_token
							}
						}
					)
					.then(resp => resp.json())
					.then(resp => {
						let channel_id = resp["data"][0]["id"];

						document.getElementById("twitchIntegrationDiv").innerHTML = "<p>Automatically queueing subs/bits to " + resp["data"][0]["display_name"] + ". If you accidentally leaked your access token (visible in URL for a split-second on page load), go to https://www.twitch.tv/settings/connections and disconnect \"Roller3D\".</p>";
						
						connect(channel_id, access_token);

						window.history.replaceState(null, null, "/roller3d/");
					})
					.catch(err => {
						logToConsoleAndDebug(err);
					});
				
				}



				// stats = new Stats();
				window.addEventListener( 'resize', onWindowResize(false) );
				window.addEventListener( 'keydown', onKeyDown );
			}

			function onWindowResize() {

				resizeCanvasToDisplaySize();

			}

			function onKeyDown( event ) {

				switch ( event.keyCode ) {

				}

			}

			function createText(message, size, height, bevelThickness, bevelSize, color) {
				var textGeo = new TextGeometry( message, {
					font: threeFont,

					size: size,
					height: height,
					curveSegments: 20,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: true

				} );

				const textMaterial = new THREE.MeshPhongMaterial( { color: color, specular: 0x111111, transparent: true } );

				var mesh = new THREE.Mesh( textGeo, textMaterial );

				textGeo.computeBoundingBox();

				mesh.position.x = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
				mesh.position.y = -0.5 * ( textGeo.boundingBox.max.y - textGeo.boundingBox.min.y );

				return mesh;
			}


			function createTextStroked(message, size, height, bevelThickness, bevelSize, color, color2) {
				let mesh = createText(message, size, height, bevelThickness, bevelSize, color); 
				let mesh2 = createText(message, size, 1, bevelThickness, bevelSize*2, color2);

				mesh2.position.x = mesh.position.x;
				mesh2.position.y = mesh.position.y;

				mesh.attach(mesh2);

				return mesh;
			}

			function createLight() {
				var lightGeo = new THREE.CylinderGeometry(5, 5, 2, 60);

				const light = new THREE.Mesh(lightGeo, [light_off_mat, light_on_mat, light_off_mat]);

				light.rotation.x = 0.5 * Math.PI;
				light.rotation.y = 0.5 * Math.PI;
				light.position.y -= 20;
				return light;
			}

			function createSlotEntry(display_str) { 

				var height = 150;
				var width = 75;
				var depth = 100;

				const metalMaterial = new THREE.MeshStandardMaterial( { 
					reflectivity: 1.0,
					transmission: 1.0,
					roughness: 0,
					metalness: 0,
					clearcoat: 0.3,
					clearcoatRoughness: 0.25,
					color: new THREE.Color(0x111111),
					ior: 1.5,
				} );

				var cubeGeo = new THREE.BoxGeometry(height, width, depth);

				var cubeMat = new THREE.MeshBasicMaterial( {color: 0x00ff00} );

				const cube = new THREE.Mesh( cubeGeo, metalMaterial );

				cube.position.y = FLOOR + 200;
				cube.position.z = -50;

				let tl_light = createLight();
				tl_light.position.x = cube.position.x - width + 8;

				let bl_light = createLight();
				bl_light.position.x = tl_light.position.x;
				bl_light.position.y = cube.position.y - height / 4 + 8;

				let tr_light = createLight();
				tr_light.position.x = cube.position.x + width - 8;

				let br_light = createLight();
				br_light.position.x = tr_light.position.x;
				br_light.position.y = bl_light.position.y;

				cube.attach(tl_light);
				cube.attach(bl_light);
				cube.attach(tr_light);
				cube.attach(br_light);

				let mesh = createTextStroked(display_str, 24, 6, 4, 2, 0x900000, 0xfbf5e9);

				mesh.geometry.computeBoundingBox();
				var center = mesh.geometry.boundingBox.getCenter(new THREE.Vector3());

				mesh.position.x = cube.position.x + -1*center.x;
				mesh.position.y = cube.position.y + -1 * center.y; //center.y;
				
				// mesh.position.y = cube.position.y + mesh.position.y/2;

				cube.attach(mesh);

				return cube;
			}

			// From https://stackoverflow.com/questions/51723338/change-the-position-of-a-piechart-slice-in-threejs
			function createSegment(display_str, radius, angleStart, angleEnd, color) {
				var extrOpt = {
					curveSegments: 32,
					steps: 1,
					depth: 150,
					bevelEnabled: false,
				};

				var shape = new THREE.Shape();
				shape.moveTo(0, 0);
				shape.absarc(0, 0, radius, angleStart, angleEnd, false);
				shape.lineTo(0, 0);

				var geom = new THREE.ExtrudeGeometry(shape, extrOpt);
				geom.rotateX(-Math.PI / 2);
				var mat = new THREE.MeshLambertMaterial({
					color: color
				});
				var mesh = new THREE.Mesh(geom, mat);
				mesh.userData.angleStart = angleStart;
				mesh.userData.angleEnd = angleEnd;

				mesh.rotateZ(Math.PI / 2);
				mesh.rotateY(Math.PI);

				let text = createTextStroked(display_str, 24, 3, 3, 1, 0x900000, 0xfbf5e9);

				text.geometry.computeBoundingBox();
				let center = text.geometry.boundingBox.getCenter(new THREE.Vector3());

				angleStart -= Math.PI/2;
				angleEnd -= Math.PI/2;

				let middleAngle = ((angleEnd + angleStart) / 2);

				let textAngleDiff = Math.asin((center.y/radius));

				middleAngle -= textAngleDiff;
				text.position.z = (Math.cos(middleAngle)*radius);
				text.position.y = (Math.sin(middleAngle)*radius);

				text.position.x = -1 * (extrOpt.depth/2 + center.x);

				text.rotateX(-1*middleAngle);

				mesh.attach(text);



				let angleDiff = angleEnd - angleStart;

				let last_angle = angleStart + 0.75 * angleDiff;

				let first_angle = angleStart + 0.25 * angleDiff;

				let tl_light = createLight();
				tl_light.position.x = -1 * (extrOpt.depth) + 7.5;
				tl_light.position.z = (Math.cos(last_angle)*radius);
				tl_light.position.y = (Math.sin(last_angle)*radius);
				tl_light.rotateZ(-1*last_angle);

				let bl_light = createLight();
				bl_light.position.x = -1 * (extrOpt.depth) + 7.5;
				bl_light.position.z = (Math.cos(first_angle)*radius);
				bl_light.position.y = (Math.sin(first_angle)*radius);
				bl_light.rotateZ(-1*first_angle);

				let tr_light = createLight();
				tr_light.position.x = -7.5;
				tr_light.position.z = (Math.cos(last_angle)*radius);
				tr_light.position.y = (Math.sin(last_angle)*radius);
				tr_light.rotateZ(-1*last_angle);
				// tr_light.position.x = mesh.position.x + width - 8;

				let br_light = createLight();
				br_light.position.x = -7.5;
				br_light.position.z = (Math.cos(first_angle)*radius);
				br_light.position.y = (Math.sin(first_angle)*radius);
				br_light.rotateZ(-1*first_angle);

				mesh.attach(tl_light);
				mesh.attach(bl_light);
				mesh.attach(tr_light);
				mesh.attach(br_light);

				return mesh;
			}

			document.querySelector('#btnToggleQueue').addEventListener('click', toggleQueue)
			function toggleQueue() {
				is_queue_active = !is_queue_active;

				if(is_queue_active) {
					document.querySelector("#btnToggleQueue").innerHTML = "STOP roll queue";
				}
				else {
					document.querySelector("#btnToggleQueue").innerHTML = "START roll queue";
				}
			}

			document.querySelector('#updateChoicesButton').addEventListener('click', updateChoices)
			function updateChoices() {
				for(let i = 0; i < segments.length; ++i) { 
					segmentGroup.remove(segments[i]);
					scene.remove(segments[i]);
				}
				scene.remove(segmentGroup);
				segments = [];

				let raw_choices = document.querySelector('#choices').value.split(/\r?\n/);
				choices = [];
				for(let i = raw_choices.length-1; i >= 0; --i) { 
					if(raw_choices[i] === "") {
						continue;
					}

					choices.push(raw_choices[i]);
				}

				let increment_per = (2*Math.PI)/choices.length;
				for(let i = 0; i < choices.length; ++i) { 
					let segment = createSegment(choices[i], 100, i * increment_per, (i+1) * increment_per, 0x111111);
					segments.push(segment);
					segmentGroup.add(segments[i]);
				}

				scene.add(segmentGroup);
			}

			document.querySelector('#roll_btn').addEventListener('click', addToQueue)

			function updateRollCount() {
				if(is_rolling) {
					scene.remove(rollCountMesh);

					if(getCurRollCount() < getCurRollTotal()) {
						rollCountMesh = createTextStroked((getCurRollCount()+1).toString() + " of " + getCurRollTotal().toString(), 20, 2, 1, 1, 0xcccccc, 0x000000);

						rollCountMesh.rotateY(-Math.PI/8);
						rollCountMesh.geometry.computeBoundingBox();
						let rollCount_width = rollCountMesh.geometry.boundingBox.max.x - rollCountMesh.geometry.boundingBox.min.x;
						rollCountMesh.position.x = (-0.5 * rollCount_width) - 70;
						rollCountMesh.position.y = -135;
						rollCountMesh.position.z = 50;

						scene.add(rollCountMesh);
					}
				}
			}

			function getTimeStampString() {
				let curDateTime = new Date();

				let year  = curDateTime.getFullYear().toString().padStart(4, '0');
				let day   = curDateTime.getDate().toString().padStart(2, '0');
				let month = (curDateTime.getMonth() + 1).toString().padStart(2, '0');

				let hour   = curDateTime.getHours();
				let am_pm  = "AM";

				if(hour >= 12){
					am_pm = "PM";

					if(hour > 12) {
						hour -= 12;
					}
				}

				hour = hour.toString().padStart(2, '0');

				let minute = curDateTime.getMinutes().toString().padStart(2, '0');
				let second = curDateTime.getSeconds().toString().padStart(2, '0');

				return day + "/" + month + "/" + year + " " + hour + ":" + minute + ":" + second + " " + am_pm;
			}

			function appendRow(spreadsheetId, sheetId, values) {
				let values_array = []

				for(let value_idx = 0; value_idx < values.length; ++value_idx) {
					values_array.push({userEnteredValue: {stringValue: values[value_idx]}})
				}

				var request = window.gapi.client.sheets.spreadsheets.batchUpdate({
				spreadsheetId: spreadsheetId,
				"resource": {
					"requests": [
						{
							"insertDimension": {
								"range": {
									"sheetId": sheetId,
									"dimension": "ROWS",
									"startIndex": 1,
									"endIndex": 2
								},
								"inheritFromBefore": false
							}
						},
						{
							"updateCells": {

								"rows": 
								{
									values: values_array
								}
								,
								"fields": "*",
								"range": {
									"sheetId": sheetId,
									"startRowIndex": 1,  // I want to write to second row only
									"endRowIndex": 2,
									"startColumnIndex": 0, // start at first column
									"endColumnIndex": 5   // end at 5th column
								}
							}
						},
						{
							"autoResizeDimensions": {
								"dimensions": {
								"sheetId": sheetId,
								"dimension": "COLUMNS",
								"startIndex": 0,
								"endIndex": values.length
								}
							}
						}
					]
				}
			});
				
				request.then(function(response) {
					// TODO: Change code below to process the `response` object:
					console.log(response.result);
					}, function(reason) {
					console.error('error: ' + reason.result.error.message);
					});
			}

			function logRoll(name, reward, timestamp_received) { 
				let spreadsheetId = window.spreadsheetId;
				if(spreadsheetId != null) {
					let sheetId = window.sheet_map.get("Rolls");
					appendRow(spreadsheetId, sheetId, [getTimeStampString(), timestamp_received, name, reward]);
				}
			}

			function logDebug(message) { 
				let spreadsheetId = window.spreadsheetId;
				if(spreadsheetId != null) {
					let sheetId = window.sheet_map.get("Debug");
					appendRow(spreadsheetId, sheetId, [getTimeStampString(), message]);
				}
			}

			// Log to console and debug
			function logToConsoleAndDebug(message) { 
				console.log(message)
				logDebug(message)
			}

			function finishCurRoll() {

				is_rolling = false;

				for (let [key, value] of rollResultsTextMesh) {
					value.traverse(addFadeTween);
				}

				nameTextMesh.traverse(addFadeTween);

				if(rollTotalCounts.size > 0) {

					let cur_name = getCurRollName();

					let resultsText = document.querySelector("#rollResults");

					let resultsMessages = [];

					for (let [key, value] of rollResultsCount) {
						resultsMessages.push(value + "x " + key);
					}

					resultsText.value = "[" + getTimeStampString() + "]" + getCurRollName() + ": " + resultsMessages.join(', ') + "\n" + resultsText.value;

					let timeStamp = getTimeStampString();

					let rollCount = getCurRollCount();

					lastRollTime = new Date();

					let api_url = document.querySelector('#sheetdb_api_url').value;

					if(api_url != "") {

						let to_write = []

						for (let [key, value] of rollResultsCount) {
							for(let i = 0; i < parseInt(value); ++i) {
								to_write.push({time_stamp: " " + timeStamp, name: cur_name, roll_count: "1", rewards: key });
							}
							resultsMessages.push(key);
						}

						write(api_url, {data: to_write}).then(function(result){
							resultsText.value = timeStamp + ": Logged " + rollCount + " roll(s) for " + cur_name + "\n" + resultsText.value;
						}, function(error){
							resultsText.value = timeStamp + ": FAILED logging " + rollCount + " roll(s) for " + cur_name + "\n" + resultsText.value;
						});
					}

					rollTotalCounts.delete(cur_name);
					rollCurSpinCounts.delete(cur_name);
					rollTimestamps.delete(cur_name);
				}
				else {
					logToConsoleAndDebug("ERROR: Trying to finish cur roll but no current roll present");
				}
			}
			function getCurRollCount() {
				if(rollCurSpinCounts.size > 0) {
					return rollCurSpinCounts.values().next().value;
				}
				
				logToConsoleAndDebug("ERR: Calling cur roll count but there are no rolls left");
				return 0;
			}
			function getCurRollTimestamp() {
				if(rollTimestamps.size > 0) {
					return rollTimestamps.get(getCurRollName())[getCurRollCount()];
				}

				logToConsoleAndDebug("ERR: Calling cur roll timestamp but there are no rolls left");
				return 0;
			}
			function getCurRollTotal() {
				if(rollTotalCounts.size > 0) {
					return rollTotalCounts.values().next().value;
				}
				
				logToConsoleAndDebug("ERR: Calling cur roll total but there are no rolls left");
				return 0;
			}

			function getCurRollSpeed() { 
				return Math.max(500, 3056.384972*(Math.pow(0.9815517441, getCurRollTotal())));
			}

			function roll_wheel() {
				is_rolling = true;

				scene.remove(nameTextMesh);

				nameTextMesh = createTextStroked("Thanks " + getCurRollName() + "!", 22, 2, 1, 1, 0x0066cc, 0x000000);

				nameTextMesh.rotateY(-Math.PI/8);
				nameTextMesh.geometry.computeBoundingBox();
				let nameText_width = nameTextMesh.geometry.boundingBox.max.x - nameTextMesh.geometry.boundingBox.min.x;
				nameTextMesh.position.x = -0.5 * nameText_width;
				nameTextMesh.position.y = 115;
				nameTextMesh.position.z = 50;

				scene.add(nameTextMesh);


				updateRollCount();
				

				// nameTextMesh.traverse(enableBloom);
				
				scene.remove(rollResultsGroup);
				rollResultsGroup = new THREE.Group();
				rollResultsCount = new Map();
				rollResultsTextMesh = new Map();

				for (let rewards_i = 0; rewards_i < rewardsFadeOut.length; ++rewards_i) {

					TWEEN.remove(rewardsFadeOut[rewards_i]);

				}
				rewardsFadeOut = [];

				startRollTween();
			}

			function startRollTween() {
				if(spinnerTween != null) {
					TWEEN.remove(spinnerTween);
				}

				spinnerTween = new TWEEN.Tween(segmentGroup.rotation)
						.to({ x: "-" + (2*Math.PI*Math.random() + 3*Math.PI)}, getCurRollSpeed())
						.easing(TWEEN.Easing.Cubic.InOut)
						.onComplete(finishOneRoll)
						.start()
			}

			function addFadeTween(obj) {
				rewardsFadeOut.push(new TWEEN.Tween(obj.material).delay(3000)
							.to({opacity: 0}, 1)
							.easing(TWEEN.Easing.Sinusoidal.In)
							.start());
			}

			function getCurRollName() {
				if(rollTotalCounts.size > 0) {
					return rollTotalCounts.keys().next().value;
				}

				logToConsoleAndDebug("ERR: Trying to get roll name but there aren't any rolls left");
				return "N/A";
			}

			function addOneRoll() {
				let cur_name = getCurRollName();

				rollCurSpinCounts.set(cur_name, getCurRollCount() + 1);
			}

			function finishOneRoll() {
				let curRollTimestamp = getCurRollTimestamp();

				addOneRoll();

				if(getCurRollCount() < getCurRollTotal()) {
					startRollTween();
				}
				else {
					if(spinnerTween != null) {
						TWEEN.remove(spinnerTween);
					}

					spinnerTween = new TWEEN.Tween(segmentGroup.rotation).delay(1000)
						.to({ x: "-" + (2*9999*Math.PI)}, 9999*5000)
						.repeat(Infinity)
						.start()
				}

				updateRollCount();

				let rollResult = choices[getHighlightedSegmentIndex()];

				logRoll(getCurRollName(), rollResult, curRollTimestamp);

				if(rollResultsCount.has(rollResult)) {
					rollResultsCount.set(rollResult, rollResultsCount.get(rollResult) + 1);

					let message = rollResultsCount.get(rollResult) + "x " + rollResult;

					let resultsBox = createTextStroked(message, 18, 2, 2, 1, 0x900000, 0x000000);

					let prevBox = rollResultsTextMesh.get(rollResult);

					resultsBox.rotateY(-Math.PI/8);
					resultsBox.position.x = prevBox.position.x;
					resultsBox.position.y = prevBox.position.y;
					resultsBox.position.z = prevBox.position.z;

					rollResultsGroup.remove(prevBox);

					rollResultsGroup.add(resultsBox);

					rollResultsTextMesh.set(rollResult, resultsBox);

					resultsBox.traverse(enableBloom);
				}
				else {
					let resultsBox = createTextStroked(rollResult, 18, 2, 2, 1, 0x900000, 0x000000);

					resultsBox.rotateY(-Math.PI/8);
					resultsBox.position.x = 30;

					let index = rollResultsCount.size;

					if(rewardsYPositions.has(index)) {
						index = rewardsYPositions.get(index);
					}
					else {
						index += 1;
					}
	
					resultsBox.position.y = 120 - index * 30;
					resultsBox.position.z = 50;

					rollResultsCount.set(rollResult, 1);
					rollResultsTextMesh.set(rollResult, resultsBox);

					resultsBox.traverse(enableBloom);
					rollResultsGroup.add(resultsBox);
				}

				scene.remove(rollResultsGroup);

				scene.add(rollResultsGroup);

				if(getCurRollCount() >= getCurRollTotal()) {
					finishCurRoll();
				}
			}

			function getHighlightedSegmentIndex() {
				segmentGroup.rotateX(0);

				let modAngle = segmentGroup.rotation.x + Math.PI;

				let percent = ((modAngle / (2*Math.PI)) + 0.75) % 1.0;

				let index = percent * segments.length;

				return Math.floor(index);
			}

			function addToQueue( ) {
				let name = document.querySelector("#nameBox").value
				let rollCount = document.querySelector("#roll_count").value

				queueRoll(name, parseInt(rollCount))

				updateRollCount();
			}

			window.addEventListener("message", (event)=>{

				console.log(event);

    		});

			function createScene( ) {
				if(spinnerTween != null) {
					TWEEN.remove(spinnerTween);
				}

				spinnerTween = new TWEEN.Tween(segmentGroup.rotation)
						.to({ x: "-" + (2*9999*Math.PI)}, 9999*5000)
						.repeat(Infinity)
						.start()

				// GROUND
				const planeMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff /*0xffb851*/ } );

				updateChoices();

				const renderScene = new RenderPass( scene, camera );

				const params = {
					exposure: 0,
					bloomStrength: 0.75,
					bloomThreshold: 0.25,
					bloomRadius: 2
				};

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.1, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				bloomComposer = new EffectComposer( renderer );
				bloomComposer.renderToScreen = false;
				bloomComposer.addPass( renderScene );
				bloomComposer.addPass( bloomPass );
				// CUBES

				const finalPass = new ShaderPass(
				new THREE.ShaderMaterial( {
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} ), 'baseTexture'
			);
			finalPass.needsSwap = true;

			finalComposer = new EffectComposer( renderer );
			finalComposer.addPass( renderScene );
			finalComposer.addPass( finalPass );
			}

			function animate() {
				requestAnimationFrame( animate );

				render();
			}

			function hasCurRoll() {
				if(rollTotalCounts.size > 0) {
					return true;
				}

				return false;
			}

			function render() {

				const delta = clock.getDelta();

				updateRollQueueDisplay();

				if(is_queue_active) {
					if(!is_rolling || (getCurRollCount() >= getCurRollTotal())) {
						let timeFromLastRoll = 999999;
						
						if(lastRollTime != null) { 
							timeFromLastRoll = ((new Date()).getTime() - lastRollTime);
						}
						
						if((hasCurRoll()) && (timeFromLastRoll > 3000)) {
							roll_wheel();
						}
					}
				}

				let index = getHighlightedSegmentIndex();

				for(let seg_idx = 0; seg_idx < segments.length; ++seg_idx) {
					if(seg_idx === index) {
						segments[seg_idx].traverse(enableBloom);
					}
					else {
						segments[seg_idx].traverse(disableBloom);
					}
				}

				renderer.clear();

				scene.traverse( darkenNonBloomed );
				scene.background = 0x00000;
				bloomComposer.render();
				scene.traverse( restoreMaterial );

				scene.background = new THREE.Color( 0x0000ff );
				finalComposer.render();

				TWEEN.update();
				// Call to re-calculate rotation x (in 0-2pi range)
				segmentGroup.rotateX(0);
			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function enableBloom( obj ) {
				obj.layers.enable(1);

				
				if(obj.geometry.type == "CylinderGeometry") {
					obj.material = [light_off_mat, light_on_mat, light_off_mat];
				}
			}

			function disableBloom( obj ) {
				obj.layers.disable(1);

				
				if(obj.geometry.type == "CylinderGeometry") {
					obj.material = [light_off_mat, light_off_mat, light_off_mat];
				}
			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}
			}

		</script>

	</body>
</html>
