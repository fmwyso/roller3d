<!DOCTYPE html>
<html lang="en">
	<style>
		* {

		box-sizing: border-box;
		overflow: hidden;
		}
		html {
		box-sizing: border-box;

		}
		*, *:before, *:after {
		box-sizing: inherit;
		}
		body { margin: 0; }
		.outer {
		}
		.frame { 
		display: flex;
		height: 100vh;
		max-width:100%;
		border: 0px solid cyan;
    	box-sizing: border-box;
		}
		#editor {
		font-family: monospace;
		padding: .5em;
		background: #444;
		color: white;
		}
		canvas { 
		min-width: 100%;
		height: 100%;
		}
		.rollDiv {
			text-align: center;
		}
		.choicesDiv {
			text-align: center;
		}
		input {
			text-align: right;
		}
		input[type=number] {
    		height: 30px;
		}
		input[type=number]::-webkit-inner-spin-button {  
			width: 14px;
			height: 30px;
		}
		input[type=number]:hover::-webkit-inner-spin-button {  
			width: 14px;
			height: 30px;
		}
		.rollResultsDiv {
			text-align: center;
		}
	</style>

	<head>
		<title>Roller3D by fmwyso</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>

		<div class="frame">
			<div id="result">
			  <canvas></canvas>
			</div>
			<div id="editor">
				<div class="rollDiv">
					<label for="rolls">Number of Rolls</label>
					<input type="number" min="1" name="roll_count" id="roll_count" value=1></input>
					<button type="button" id="roll_btn">Roll!</button>
				</div>

				<div class="choicesDiv">
					<label for="choices">Possible Choices</label>
					<br />
					<textarea id="choices" name="choices" rows="12" cols="50">Turkey&#13;&#10;Ham&#13;&#10;Eggs&#13;&#10;Gravy&#13;&#10;Apples&#13;&#10;Macaroni&#13;&#10;Eggnog</textarea>
					<br />
					<button type="button" id="updateChoicesButton">Update Choices</button>
				</div>

				<div class="rollResultsDiv">
					<label for="rollResults">Roll Results</label>
					<br />
					<textarea id="rollResults" name="rollResults" rows="12" cols="50" readonly></textarea>
				</div>

				<div class="rollDiv" style="text-align: center">
					<p>
						Written by fmwyso; feel free to send any comments, questions or suggestions to me on Discord (fmwyso#3492).

						<br />
						This page heavily uses <a href="https://threejs.org/">threejs</a> and <a href="https://createjs.com/tweenjs">tweenjs</a>. 
						I want to thank the following authors/pages for their examples & code snippets that made this development possible.

						<br />
						<a href="https://threejs.org/examples/?q=bloom#webgl_postprocessing_unreal_bloom_selective">Temdog007's threejs example</a>
						<br />
						<a href="https://threejs.org/examples/webgl_shadowmap.html">threejs webgl_shadowmap example</a>
						<br />
						<a href="http://stemkoski.github.io/Three.js/index.html">stemkoski's threejs examples</a>
						<br />
						<a href="https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container">gman's stackoverflow reply on resizing canvas</a>
						<br />
						<a href="https://discourse.threejs.org/t/load-font-into-global-variable-efficiency/31608/2">hofk's reply on font loading for threejs</a>
					</p>
				</div>
			</div>
		  </div>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.138.0/build/three.module.js"
				}
			}
		</script>

		<script type="x-shader/x-vertex" id="vertexshader">

			varying vec2 vUv;

			void main() {

				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D baseTexture;
			uniform sampler2D bloomTexture;

			varying vec2 vUv;

			void main() {

				gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

			}

		</script>
		
		<script type="module">

			import * as THREE from 'three';

			import Stats from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/libs/stats.module.js';

			import { GLTFLoader } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/loaders/GLTFLoader.js';
			import { FontLoader } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/loaders/FontLoader.js';
			import { TextGeometry } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/geometries/TextGeometry.js';
			import { ShadowMapViewer } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/utils/ShadowMapViewer.js';
			import { RoomEnvironment} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/environments/RoomEnvironment.js';
			import { UnrealBloomPass} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/UnrealBloomPass.js';
			import { RenderPass} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/RenderPass.js';
			import { EffectComposer} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/EffectComposer.js';
			import { ShaderPass} from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/postprocessing/ShaderPass.js';

			import { TWEEN } from 'https://unpkg.com/three@0.139.0/examples/jsm/libs/tween.module.min.js';

			const light_on_map = new THREE.TextureLoader().load( 'light_on.jpg' );
			light_on_map.wrapS = light_on_map.wrapT = THREE.RepeatWrapping;
			light_on_map.anisotropy = 16;

			const light_off_map = new THREE.TextureLoader().load( 'black.jpg' );
			light_off_map.wrapS = light_off_map.wrapT = THREE.RepeatWrapping;
			light_off_map.anisotropy = 16;

			const light_on_mat = new THREE.MeshPhongMaterial( { map: light_on_map, side: THREE.DoubleSide } );
			const light_off_mat = new THREE.MeshPhongMaterial( { map: light_off_map, side: THREE.DoubleSide } );

			const darkMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );
			const materials = {};

			var rollResultsCount = new Map();
			var rollResultsTextMesh = new Map();
			let rollResultsGroup = new THREE.Group();
			
			const SHADOW_MAP_WIDTH = 2048, SHADOW_MAP_HEIGHT = 1024;

			let SCREEN_WIDTH = window.innerWidth;
			let SCREEN_HEIGHT = window.innerHeight;
			const FLOOR = - 250;

			let camera, scene, renderer, bloomComposer, finalComposer;
			let bloomLayer;
			let container, stats;

			let segments = [];
			let choices = [];
			const segmentGroup = new THREE.Group();
			let rewardsFadeOut = [];

			let rewardsYPositions = new Map([
				[0, 4],
				[1, 5],
				[2, 3], 
				[3, 6], 
				[4, 2], 
				[5, 7], 
				[6, 1], 
				[7, 8], 
				[8, 0], 
				[9, 9]
			]);

			const NEAR = 10, FAR = 3000;

			const morphs = [];

			let light;
			let lightShadowMapViewer;

			const clock = new THREE.Clock();

			let rollsLeft = 0;
			let rollSpeed = 0;

			// From https://discourse.threejs.org/t/load-font-into-global-variable-efficiency/31608/2
			const fontLoader = new FontLoader();
			let threeFont;
			fontLoader.load( '//cdn.rawgit.com/mrdoob/three.js/master/examples/fonts/gentilis_bold.typeface.json', font => { threeFont = font; init(); animate(); } );

			// https://stackoverflow.com/questions/29884485/threejs-canvas-size-based-on-container
			function resizeCanvasToDisplaySize(skip_composer) {
				const canvas = renderer.domElement;
				const width = canvas.clientWidth;
				const height = canvas.clientHeight;
				if (canvas.width !== width ||canvas.height !== height) {
					// you must pass false here or three.js sadly fights the browser
					renderer.setSize(width, height, false);

					if(skip_composer === false) {
						bloomComposer.setSize(width, height);
						finalComposer.setSize(width, height);
					}
					camera.updateProjectionMatrix();
  				}
			}

			function init() {

				bloomLayer = new THREE.Layers();
				bloomLayer.set( 1 );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 23, 1920 / 1080, NEAR, FAR );
				camera.position.set(-200, 0, 800 );
				camera.rotateY(-.40);
				// camera.position.set(-300, 80, 200);
				// SCENE
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 /*0x59472b*/ );

				// LIGHTS

				const ambient = new THREE.AmbientLight( 0x444444 );
				scene.add( ambient );

				light = new THREE.SpotLight( 0xffffff, 1, 0, Math.PI / 5, 0.3 );
				light.position.set( 0, 1500, 1000 );
				light.target.position.set( 0, 0, 0 );

				light.castShadow = true;
				light.shadow.camera.near = 1200;
				light.shadow.camera.far = 2500;
				light.shadow.bias = 0.0001;

				light.shadow.mapSize.width = SHADOW_MAP_WIDTH;
				light.shadow.mapSize.height = SHADOW_MAP_HEIGHT;

				scene.add( light );

				// RENDERER

				renderer = new THREE.WebGLRenderer( { canvas: document.querySelector("canvas"),  antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				resizeCanvasToDisplaySize(true);

				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.autoClear = false;

				//
				renderer.shadowMap.enabled = true;
				renderer.shadowMap.type = THREE.PCFShadowMap;

				// CONTROLS


				createHUD();
				createScene();

				// STATS

				// stats = new Stats();
				window.addEventListener( 'resize', onWindowResize(false) );
				window.addEventListener( 'keydown', onKeyDown );
			}

			function onWindowResize() {

				resizeCanvasToDisplaySize();

			}

			function onKeyDown( event ) {

				switch ( event.keyCode ) {

				}

			}

			function createHUD() {

				lightShadowMapViewer = new ShadowMapViewer( light );
				lightShadowMapViewer.position.x = 10;
				lightShadowMapViewer.position.y = SCREEN_HEIGHT - ( SHADOW_MAP_HEIGHT / 4 ) - 10;
				lightShadowMapViewer.size.width = SHADOW_MAP_WIDTH / 4;
				lightShadowMapViewer.size.height = SHADOW_MAP_HEIGHT / 4;
				lightShadowMapViewer.update();

			}

			function createText(message, size, height, bevelThickness, bevelSize, color) {
				var textGeo = new TextGeometry( message, {
					font: threeFont,

					size: size,
					height: height,
					curveSegments: 20,

					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: true

				} );

				const textMaterial = new THREE.MeshPhongMaterial( { color: color, specular: 0x111111, transparent: true } );

				var mesh = new THREE.Mesh( textGeo, textMaterial );

				textGeo.computeBoundingBox();

				mesh.position.x = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
				mesh.position.y = -0.5 * ( textGeo.boundingBox.max.y - textGeo.boundingBox.min.y );
				
				mesh.castShadow = true;
				mesh.receiveShadow = true;

				return mesh;
			}


			function createTextStroked(message, size, height, bevelThickness, bevelSize, color, color2) {
				let mesh = createText(message, size, height, bevelThickness, bevelSize, color); 
				let mesh2 = createText(message, size, 1, bevelThickness, bevelSize*2, color2);

				mesh2.position.x = mesh.position.x;
				mesh2.position.y = mesh.position.y;

				mesh.attach(mesh2);

				return mesh;
			}

			function createLight() {
				var lightGeo = new THREE.CylinderGeometry(5, 5, 2, 60);

				const light = new THREE.Mesh(lightGeo, [light_off_mat, light_on_mat, light_off_mat]);

				light.rotation.x = 0.5 * Math.PI;
				light.rotation.y = 0.5 * Math.PI;
				light.position.y -= 20;
				return light;
			}

			function createSlotEntry(display_str) { 

				var height = 150;
				var width = 75;
				var depth = 100;

				const metalMaterial = new THREE.MeshStandardMaterial( { 
					reflectivity: 1.0,
					transmission: 1.0,
					roughness: 0,
					metalness: 0,
					clearcoat: 0.3,
					clearcoatRoughness: 0.25,
					color: new THREE.Color(0x111111),
					ior: 1.5,
				} );

				var cubeGeo = new THREE.BoxGeometry(height, width, depth);

				var cubeMat = new THREE.MeshBasicMaterial( {color: 0x00ff00} );

				const cube = new THREE.Mesh( cubeGeo, metalMaterial );

				cube.castShadow = true;
				cube.receiveShadow = true;

				cube.position.y = FLOOR + 200;
				cube.position.z = -50;

				let tl_light = createLight();
				tl_light.position.x = cube.position.x - width + 8;

				let bl_light = createLight();
				bl_light.position.x = tl_light.position.x;
				bl_light.position.y = cube.position.y - height / 4 + 8;

				let tr_light = createLight();
				tr_light.position.x = cube.position.x + width - 8;

				let br_light = createLight();
				br_light.position.x = tr_light.position.x;
				br_light.position.y = bl_light.position.y;

				cube.attach(tl_light);
				cube.attach(bl_light);
				cube.attach(tr_light);
				cube.attach(br_light);

				let mesh = createTextStroked(display_str, 24, 6, 4, 2, 0x900000, 0xfbf5e9);

				mesh.geometry.computeBoundingBox();
				var center = mesh.geometry.boundingBox.getCenter(new THREE.Vector3());

				mesh.position.x = cube.position.x + -1*center.x;
				mesh.position.y = cube.position.y + -1 * center.y; //center.y;
				
				// mesh.position.y = cube.position.y + mesh.position.y/2;

				cube.attach(mesh);

				return cube;
			}

			// From https://stackoverflow.com/questions/51723338/change-the-position-of-a-piechart-slice-in-threejs
			function createSegment(display_str, radius, angleStart, angleEnd, color) {
				var extrOpt = {
					curveSegments: 32,
					steps: 1,
					depth: 150,
					bevelEnabled: false,
				};

				var shape = new THREE.Shape();
				shape.moveTo(0, 0);
				shape.absarc(0, 0, radius, angleStart, angleEnd, false);
				shape.lineTo(0, 0);

				var geom = new THREE.ExtrudeGeometry(shape, extrOpt);
				geom.rotateX(-Math.PI / 2);
				var mat = new THREE.MeshLambertMaterial({
					color: color
				});
				var mesh = new THREE.Mesh(geom, mat);
				mesh.userData.angleStart = angleStart;
				mesh.userData.angleEnd = angleEnd;

				mesh.rotateZ(Math.PI / 2);
				mesh.rotateY(Math.PI);

				mesh.castShadow = true;
				// mesh.receiveShadow = true;

				let text = createTextStroked(display_str, 24, 3, 3, 1, 0x900000, 0xfbf5e9);

				text.geometry.computeBoundingBox();
				let center = text.geometry.boundingBox.getCenter(new THREE.Vector3());

				angleStart -= Math.PI/2;
				angleEnd -= Math.PI/2;

				let middleAngle = ((angleEnd + angleStart) / 2);

				let textAngleDiff = Math.asin((center.y/radius));

				middleAngle -= textAngleDiff;
				text.position.z = (Math.cos(middleAngle)*radius);
				text.position.y = (Math.sin(middleAngle)*radius);

				text.position.x = -1 * (extrOpt.depth/2 + center.x);

				text.rotateX(-1*middleAngle);

				mesh.attach(text);



				let angleDiff = angleEnd - angleStart;

				let last_angle = angleStart + 0.75 * angleDiff;

				let first_angle = angleStart + 0.25 * angleDiff;

				let tl_light = createLight();
				tl_light.position.x = -1 * (extrOpt.depth) + 7.5;
				tl_light.position.z = (Math.cos(last_angle)*radius);
				tl_light.position.y = (Math.sin(last_angle)*radius);
				tl_light.rotateZ(-1*last_angle);

				let bl_light = createLight();
				bl_light.position.x = -1 * (extrOpt.depth) + 7.5;
				bl_light.position.z = (Math.cos(first_angle)*radius);
				bl_light.position.y = (Math.sin(first_angle)*radius);
				bl_light.rotateZ(-1*first_angle);

				let tr_light = createLight();
				tr_light.position.x = -7.5;
				tr_light.position.z = (Math.cos(last_angle)*radius);
				tr_light.position.y = (Math.sin(last_angle)*radius);
				tr_light.rotateZ(-1*last_angle);
				// tr_light.position.x = mesh.position.x + width - 8;

				let br_light = createLight();
				br_light.position.x = -7.5;
				br_light.position.z = (Math.cos(first_angle)*radius);
				br_light.position.y = (Math.sin(first_angle)*radius);
				br_light.rotateZ(-1*first_angle);

				mesh.attach(tl_light);
				mesh.attach(bl_light);
				mesh.attach(tr_light);
				mesh.attach(br_light);

				return mesh;
			}

			document.querySelector('#updateChoicesButton').addEventListener('click', updateChoices)
			function updateChoices() {
				for(let i = 0; i < segments.length; ++i) { 
					segmentGroup.remove(segments[i]);
					scene.remove(segments[i]);
				}
				scene.remove(segmentGroup);
				segments = [];

				let raw_choices = document.querySelector('#choices').value.split(/\r?\n/);
				choices = [];
				for(let i = raw_choices.length-1; i >= 0; --i) { 
					if(raw_choices[i] === "") {
						continue;
					}

					choices.push(raw_choices[i]);
				}

				let increment_per = (2*Math.PI)/choices.length;
				for(let i = 0; i < choices.length; ++i) { 
					let segment = createSegment(choices[i], 100, i * increment_per, (i+1) * increment_per, 0x111111);
					segments.push(segment);
					segmentGroup.add(segments[i]);
				}

				scene.add(segmentGroup);
			}

			document.querySelector('#roll_btn').addEventListener('click', roll_wheel)

			function roll_wheel() {
				rollsLeft = document.querySelector("#roll_count").value
				rollSpeed = Math.max(500, 3056.384972*(Math.pow(0.9815517441, rollsLeft)))
				
				scene.remove(rollResultsGroup);
				rollResultsGroup = new THREE.Group();
				rollResultsCount = new Map();
				rollResultsTextMesh = new Map();

				for (let rewards_i = 0; rewards_i < rewardsFadeOut.length; ++rewards_i) {

					TWEEN.remove(rewardsFadeOut[rewards_i]);

				}
				rewardsFadeOut = [];

				startRollTween();
			}

			function startRollTween() {
				var tweener = new TWEEN.Tween(segmentGroup.rotation)
						.to({ x: "-" + (2*Math.PI*Math.random() + 3*Math.PI)}, rollSpeed)
						.easing(TWEEN.Easing.Exponential.InOut)
						.onComplete(finishOneRoll)
						.start()
			}

			function addFadeTween(obj) {
				rewardsFadeOut.push(new TWEEN.Tween(obj.material).delay(10000)
							.to({opacity: 0}, 1)
							.easing(TWEEN.Easing.Sinusoidal.In)
							.start());
			}

			function finishOneRoll() {
				rollsLeft -= 1;
				if(rollsLeft > 0) {
					startRollTween();
				}

				let rollResult = choices[getHighlightedSegmentIndex()];

				if(rollResultsCount.has(rollResult)) {
					rollResultsCount.set(rollResult, rollResultsCount.get(rollResult) + 1);

					let message = rollResultsCount.get(rollResult) + "x " + rollResult;

					let resultsBox = createTextStroked(message, 20, 2, 2, 1, 0x900000, 0x000000);
					resultsBox.receiveShadow = false;
					resultsBox.castShadow = false;

					let prevBox = rollResultsTextMesh.get(rollResult);

					resultsBox.rotateY(-Math.PI/8);
					resultsBox.position.x = prevBox.position.x;
					resultsBox.position.y = prevBox.position.y;
					resultsBox.position.z = prevBox.position.z;

					rollResultsGroup.remove(prevBox);

					rollResultsGroup.add(resultsBox);

					rollResultsTextMesh.set(rollResult, resultsBox);

					resultsBox.traverse(enableBloom);
				}
				else {
					let resultsBox = createTextStroked(rollResult, 20, 2, 2, 1, 0x900000, 0x000000);
					resultsBox.receiveShadow = false;
					resultsBox.castShadow = false;

					resultsBox.rotateY(-Math.PI/8);
					resultsBox.position.x = 30;

					let index = rollResultsCount.size;

					if(rewardsYPositions.has(index)) {
						index = rewardsYPositions.get(index);
					}
	
					resultsBox.position.y = 135 - index * 32;
					resultsBox.position.z = 50;

					rollResultsCount.set(rollResult, 1);
					rollResultsTextMesh.set(rollResult, resultsBox);

					resultsBox.traverse(enableBloom);
					rollResultsGroup.add(resultsBox);
				}

				scene.remove(rollResultsGroup);

				scene.add(rollResultsGroup);

				if(rollsLeft == 0) {
					for (let [key, value] of rollResultsTextMesh) {
						value.traverse(addFadeTween);
					}

					let resultsText = document.querySelector("#rollResults");

					let resultsMessages = [];

					for (let [key, value] of rollResultsCount) {
						resultsMessages.push(value + "x " + key);
					}

					resultsText.value = resultsMessages.join(', ') + "\n\n" + resultsText.value;
				}
			}

			function getHighlightedSegmentIndex() {
				segmentGroup.rotateX(0);

				let modAngle = segmentGroup.rotation.x + Math.PI;

				let percent = ((modAngle / (2*Math.PI)) + 0.75) % 1.0;

				let index = percent * segments.length;

				return Math.floor(index);
			}

			function createScene( ) {

				// GROUND
				const planeMaterial = new THREE.MeshPhongMaterial( { color: 0x0000ff /*0xffb851*/ } );

				updateChoices();

				const renderScene = new RenderPass( scene, camera );

				const params = {
					exposure: 0,
					bloomStrength: 0.75,
					bloomThreshold: 0.25,
					bloomRadius: 2
				};

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.1, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				bloomComposer = new EffectComposer( renderer );
				bloomComposer.renderToScreen = false;
				bloomComposer.addPass( renderScene );
				bloomComposer.addPass( bloomPass );
				// CUBES

				const finalPass = new ShaderPass(
				new THREE.ShaderMaterial( {
					uniforms: {
						baseTexture: { value: null },
						bloomTexture: { value: bloomComposer.renderTarget2.texture }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					defines: {}
				} ), 'baseTexture'
			);
			finalPass.needsSwap = true;

			finalComposer = new EffectComposer( renderer );
			finalComposer.addPass( renderScene );
			finalComposer.addPass( finalPass );

				const cubes1 = new THREE.Mesh( new THREE.BoxGeometry( 1500, 220, 150 ), planeMaterial );

				cubes1.position.y = FLOOR - 50;
				cubes1.position.z = 20;

				cubes1.castShadow = true;
				cubes1.receiveShadow = true;

				// scene.add( cubes1 );

				const cubes2 = new THREE.Mesh( new THREE.BoxGeometry( 1600, 170, 250 ), planeMaterial );

				cubes2.position.y = FLOOR - 50;
				cubes2.position.z = 20;

				cubes2.castShadow = true;
				cubes2.receiveShadow = true;

				// scene.add( cubes2 );
			}

			function animate() {
				requestAnimationFrame( animate );

				render();
			}

			function render() {

				const delta = clock.getDelta();

				if(rollsLeft <= 0) {
					segmentGroup.rotateX(-1.0 * delta);
				}

				let index = getHighlightedSegmentIndex();

				for(let seg_idx = 0; seg_idx < segments.length; ++seg_idx) {
					if(seg_idx === index) {
						segments[seg_idx].traverse(enableBloom);
					}
					else {
						segments[seg_idx].traverse(disableBloom);
					}
				}

				renderer.clear();

				scene.traverse( darkenNonBloomed );
				scene.background = 0x00000;
				bloomComposer.render();
				scene.traverse( restoreMaterial );

				scene.background = new THREE.Color( 0x0000ff );
				finalComposer.render();

				TWEEN.update();
				// Call to re-calculate rotation x (in 0-2pi range)
				segmentGroup.rotateX(0);
			}

			function renderBloom( mask ) {

				if ( mask === true ) {

					scene.traverse( darkenNonBloomed );
					bloomComposer.render();
					scene.traverse( restoreMaterial );

				} else {

					camera.layers.set( BLOOM_SCENE );
					bloomComposer.render();
					camera.layers.set( ENTIRE_SCENE );

				}

			}

			function enableBloom( obj ) {
				obj.layers.enable(1);

				
				if(obj.geometry.type == "CylinderGeometry") {
					obj.material = [light_off_mat, light_on_mat, light_off_mat];
				}
			}

			function disableBloom( obj ) {
				obj.layers.disable(1);

				
				if(obj.geometry.type == "CylinderGeometry") {
					obj.material = [light_off_mat, light_off_mat, light_off_mat];
				}
			}

			function darkenNonBloomed( obj ) {

				if ( obj.isMesh && bloomLayer.test( obj.layers ) === false ) {

					materials[ obj.uuid ] = obj.material;
					obj.material = darkMaterial;

				}

			}

			function restoreMaterial( obj ) {

				if ( materials[ obj.uuid ] ) {

					obj.material = materials[ obj.uuid ];
					delete materials[ obj.uuid ];

				}
			}

		</script>

	</body>
</html>
